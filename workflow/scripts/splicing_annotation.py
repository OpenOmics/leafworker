#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Author: Skyler Kuhn

# Standard Library
from __future__ import print_function
from datetime import datetime
from textwrap import dedent
import argparse, gzip, os, sys

# Constants
# Usage and help section 
_HELP = dedent("""
@Usage:
    $ ./splicing_annotation.py [-h] [--version] \\
            --exon-ann EXON_ANN_FILE \\
            --output OUTPUT_FILE
@About:
    Given an exon annotation (see output file of
    exon_annotation.py), this script will create
    a tab-separated file with the splicing info
    for each transcript. For each transcript,
    the following information will be included:
        • gene_id
        • gene_name
        • transcript_id
        • transcript_name
        • exon_id.1|exon_id.2|...
        • exon_number.1|exon_number.2|...
        • exon_seqname
        • exon_start:exon_end.1|exon_start.2|...
        • exon_strand

    This file has 1:M exon information collapsed by
    their genomic position, where 1:M fields are
    sorted by their start/end position, and mutiple
    exons are separated by a pipe character "|".

@Required:
    -e, --exon-ann EXON_ANN_FILE
        Input exon annotation file. This file
        was generated by parsing exon info
        from the GTF file. It is the output
        file of "exon_annotation.py".
    -o, --output OUTPUT_FILE
        Output file with transcript collapsed
        exon information. This represent the
        transcript model for each gene.
@Options:
    -h, --help
        Shows help message and exits.
    -v, --version
        Prints the version and exits.

@Example:
    $ ./splicing_annotation.py \\
        -e exon_annotation.tsv \\
        -o splicing_annotation.tsv
"""
)

# Semantic version
_VERISON = '1.0.0'


# Helper functions
def err(*message, **kwargs):
    """Prints any provided args to standard error.
    kwargs can be provided to modify print functions
    behavior.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    print(*message, file=sys.stderr, **kwargs)


def fatal(*message, **kwargs):
    """Prints any provided args to standard error
    and exits with an exit code of 1.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    err(*message, **kwargs)
    sys.exit(1)


def timestamp(format="%Y-%m-%d %H:%M:%S"):
    """Returns a formatted timestamp string
    for the current time.
    @param format <str>:
        Format string for the timestamp, default:
        "%Y-%m-%d %H:%M:%S" which is equivalent to
        "2023-10-01 12:00:00" for example.
    @return <str>:
        Formatted timestamp string, i.e. "2023-10-01 12:00:00"
    """
    return datetime.now().strftime(format)


def log(*message):
    """Logs a message to standard output with a timestamp.
    @param message <any>:
        Values printed to log
    """
    print("[{0}] {1}".format(
        timestamp(),
        " ".join([str(m) for m in message]))
    )


def check_permissions(parser, path, *args, **kwargs):
    """Checks permissions using os.access() to see the
    user is authorized to access a file/directory. Checks
    for existence, read, write and execute via args:
        • os.F_OK (tests existence)
        • os.R_OK (tests read)
        • os.W_OK (tests write)
        • os.X_OK (tests exec)
    @param parser <argparse.ArgumentParser() object>:
        Argparse parser object
    @param path <str>:
        Name of path to check
    @param args <any>:
        Positional args to pass to os.access()
    @param kwargs <any>:
        Named kwargs to pass to os.access()
    @return path <str>:
        Returns absolute path if it exists and the
        checked permssions are setup are correct.
    """
    if not os.path.exists(path):
        parser.error(
            "Path '{}' does not exists! Failed to provide vaild input.".format(path)
        )
    if not os.access(path, *args, **kwargs):
        parser.error(
            "Path '{}' exists, but cannot read path due to permissions!".format(path)
        )
    return os.path.abspath(path)


def parse_cli_arguments():
    """Parses command line arguments and returns
    an argparse.parse_args object.
    @return <argparse.parse_args()>:
        Parsed command line arguments
    """
    parser = argparse.ArgumentParser(
        add_help=False,
        description=_HELP,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage = argparse.SUPPRESS,
    )
    # Exon annotation file
    parser.add_argument(
        '-e', '--exon-ann',
        type = lambda file: \
            check_permissions(parser, file, os.R_OK),
        required=True,
        help=argparse.SUPPRESS
    )
    # Annotated output results
    parser.add_argument(
        '-o', '--output',
        type = str,
        required=True,
        help=argparse.SUPPRESS
    )
    # Get version information
    parser.add_argument(
        '-v', '--version',
        action='version',
        help = argparse.SUPPRESS,
        version='%(prog)s {0}'.format(_VERISON)
    )
    # Add custom help message
    parser.add_argument(
        '-h', '--help',
        action='help',
        help=argparse.SUPPRESS
    )
    return parser.parse_args()


def stripped(s):
    """Cleans string to remove quotes
    @param s <str>:
        String to remove quotes or clean
    @return s <str>:
        Cleaned string with quotes removed
    """
    return s.strip('"').strip("'")


def index_header(file_header):
    """Returns the index of each column_name
    as a dictionary.
    @param file_header <str>:
        First line of a file, containing column names
    @return idx <dict[str]=int>:
        Column name to index dictionary
    """
    idx = {}
    tokens = [
        stripped(c.strip()) \
            for c in file_header.strip().split('\t')
    ]
    # Create column name to index mapping
    for i,c in enumerate(tokens):
        idx[c]=i
    return idx


def index_file(
        file, key = "transcript_id", 
        single_value_columns=["gene_id", "gene_name", "transcript_name"],
        multi_value_columns=["exon_id", "exon_number", "exon_seqname","exon_start", "exon_end", "exon_strand"],
        multi_value_key_name="exon_metadata"
    ):
    """Parses and indexes a file into a dictionary for quick
    lookups later. This file is indexed by keys representing
    transcript_ids and a nested dictionary of containing the
    following information:
        • gene_id
        • gene_name
        • transcript_name
        • exon_metadata (list of lists):
            • [[id, number, seqname, start, end, strand], ...]
    @param file <str>:
        File to parse and index. Must contain a header with
        the columns listed in keys and values. The index of
        these columns will be automatically resolved.
    @param key <str>:
        Key to use for the first level of the index. Defaults
        to "transcript_id". This is the first key in the
        nested dictionary.
    @param single_value_columns <list[str]>:
        List of columns that contain single values per key.
        These are the second keys in the nested dictionary.
    @param multi_value_columns <list[str]>:
        List of columns that contain multiple values per key.
        These values are stored as a list of lists in the
        nested dictionary under the key "exon_metadata".
        This represents the exon information for each
        transcript. Each element in the returned list is
        a list containing the following information:
            • [0] exon_id
            • [1] exon_number
            • [2] exon_seqname
            • [3] exon_start
            • [4] exon_end
            • [5] strand
    @param multi_value_key_name <str>:
        Name of the key in the nested dictionary that contains
        the multi-value columns. Defaults to "exon_metadata".
    @return file_idx <dict[str]=str>:
        Nested dictionary where,
            • 1st_key = transcript_id
            • 2nd_key = one of the following:
              gene_id|gene_name|transcript_name|exon_metadata
    @note: file_idx[transcript_id][exon_metadata] returns a
    list of lists, where each element in the list has been
    sorted on seqname, start, end, strand.
    """
    log("Started indexing input file: {0}".format(file))
    file_idx = {}
    # Handler for opening files, i.e.
    # uncompressed or gzip files
    open_func = gzip.open if file.endswith('.gz') else open
    line_number = 0  # Used for error reporting 
    with open_func(file, 'rt') as fh:
        header = next(fh)
        col_idx = index_header(header)
        for line in fh:
            # Increment line number
            line_number += 1
            # Split the line into columns
            tokens = line.strip().split('\t')
            # Concatenate mutiple keys into
            # a single key separated by the
            # key_delim character
            _k = tokens[col_idx[key]]
            _v = {v: tokens[col_idx[v]] for v in single_value_columns if v in col_idx}
            if _k not in file_idx:
                # Create a new entry in the index
                # with the single value columns
                # this prevents it from being
                # overwritten in every iteration.
                # The values in _v should be the
                # same on every line for each
                # transcript_id.
                file_idx[_k] = _v
            # Parse multi-value columns
            _multi_values = [tokens[col_idx[v]] for v in multi_value_columns if v in col_idx]
            # Add multi-value columns to the
            # file_idx under the multi_value_key_name
            if multi_value_key_name not in file_idx[_k]:
                file_idx[_k][multi_value_key_name] = []
            # Append the multi-value columns
            file_idx[_k][multi_value_key_name].append(_multi_values)
    log("Finished indexing input file: {0} ({1} lines)".format(file, line_number))
    return file_idx 


def get_additional_annotation_information(annotation_dict, first_key, values):
    """Get additional annotation information from a nested 
    dictionary using the first_key and each value in values
    as a composite key. Returns a list of values corresponding
    to the provided (first_key, value) pairs in annotation_dict.
    If a key is not found, it returns "NA" for that value.
    @param annotation_dict <dict>:
        Nested dictionary containing additional annotation information
        keyed by [first_key][v] where v is an element in values.
    @param first_key <str>:
        First key in the nested dictionary to use for lookups.
    @param values <list[str]>:
        List of values to retrieve from the dictionary. This is
        the second key in the nested dictionary.
    @return <list[str]>:
        Returns a list of values corresponding to the provided keys.
        If a key is not found, it returns "NA" for that value.
    """
    return [annotation_dict.get(first_key, {}).get(v, "NA") for v in values]


if __name__ == '__main__':
    # Parse command line arguments
    args = parse_cli_arguments()
    
    # Sanity check for usage
    if len(sys.argv) == 1:
        # Nothing was provided
        fatal('Invalid usage: {0} [-h] ...'.format(os.path.basename(sys.argv[0])))
    
    log("Running splicing annotation script with the following options: ", args)
    # Create output directory if
    # it does not exist
    output_dir = os.path.abspath(os.path.dirname(args.output))
    if not os.path.exists(output_dir):
        try: os.makedirs(output_dir)
        except OSError as e: 
            fatal(
                "Fatal error: Failed to create output directory: {0}\n{1}".format(
                    output_dir, e
                )
            )
    
    # Parse and collapse exon annotation
    # information for each transcript,
    # where 1:M exon information is
    # sorted by chr/start/end/strand,
    # meaning it is in the same order
    # as the spliced transcript.
    FIRST_KEY = "transcript_id"
    EXON_1toM_KEY = "exon_metadata"
    PARSE_1to1_COLUMNS = [
        "gene_id",
        "gene_name",
        "transcript_name"
    ]
    PARSE_1toM_COLUMNS = [
        "exon_id",
        "exon_number",
        "exon_seqname",
        "exon_start",
        "exon_end",
        "exon_strand"
    ]
    splicing_dict = index_file(
        file=args.exon_ann,
        key = FIRST_KEY, 
        single_value_columns=PARSE_1to1_COLUMNS,
        multi_value_columns=PARSE_1toM_COLUMNS,
        multi_value_key_name=EXON_1toM_KEY
    )
    log("Starting sorting exon information by seqname, start, end, strand")
    # Sort the multi-value columns by
    # seqname, start, end, strand
    for k, v in splicing_dict.items():
        if EXON_1toM_KEY in v:
            # Sort the list of lists by:
            # seqname, start, end, strand
            v[EXON_1toM_KEY].sort(
                key=lambda x: (x[2], int(x[3]), int(x[4]), x[5])
            )
            # Get the strand information
            # for the first exon in the list
            # to determine if the order
            # needs to be reversed.
            if v[EXON_1toM_KEY][0][5] == "-":
                # If the strand is negative, 
                # reverse the order of the exon
                # information to reflect the
                # correct splicing order.
                v[EXON_1toM_KEY].reverse()
    log("Finished sorting exon information by seqname, start, end, strand")