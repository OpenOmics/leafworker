#!/usr/bin/env python3
# -*- coding: UTF-8 -*-
# Author: Skyler Kuhn

# Standard Library
from __future__ import print_function
from datetime import datetime
from textwrap import dedent
import argparse, gzip, os, sys

# Constants
# Usage and help section
_HELP = dedent("""
@Usage:
    $ ./splicing_annotation.py [-h] [--version] \\
            --exon-ann EXON_ANN_FILE \\
            --output OUTPUT_FILE
@About:
    Given an exon annotation (see output file of
    exon_annotation.py), this script will create
    a tab-separated file with the splicing info
    for each transcript. For each transcript the
    following information will be included:
        • transcript_id
        • transcript_name
        • gene_id
        • gene_name
        • exon_id.1|exon_id.2|...
        • exon_number.1|exon_number.2|...
        • exon_seqname
        • exon_start:exon_end.1|exon_start.2:exon_end.2|...
        • exon_strand

    This file has 1:M exon information collapsed by
    their genomic position, where 1:M fields are
    sorted by their start/end position, and mutiple
    exons are separated by a pipe character "|".

@Required:
    -e, --exon-ann EXON_ANN_FILE
        Input exon annotation file. This file
        was generated by parsing exon info
        from the GTF file. It is the output
        file of "exon_annotation.py".
    -o, --output OUTPUT_FILE
        Output file with transcript collapsed
        exon information. This represent the
        transcript model for each gene.
@Options:
    -h, --help
        Shows help message and exits.
    -v, --version
        Prints the version and exits.

@Example:
    $ ./splicing_annotation.py \\
        -e exon_annotation.tsv \\
        -o splicing_annotation.tsv
"""
)

# Semantic version
_VERISON = '1.0.0'


# Helper functions
def err(*message, **kwargs):
    """Prints any provided args to standard error.
    kwargs can be provided to modify print functions
    behavior.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    print(*message, file=sys.stderr, **kwargs)


def fatal(*message, **kwargs):
    """Prints any provided args to standard error
    and exits with an exit code of 1.
    @param message <any>:
        Values printed to standard error
    @params kwargs <print()>
        Key words to modify print function behavior
    """
    err(*message, **kwargs)
    sys.exit(1)


def timestamp(format="%Y-%m-%d %H:%M:%S"):
    """Returns a formatted timestamp string
    for the current time.
    @param format <str>:
        Format string for the timestamp, default:
        "%Y-%m-%d %H:%M:%S" which is equivalent to
        "2023-10-01 12:00:00" for example.
    @return <str>:
        Formatted timestamp string, i.e. "2023-10-01 12:00:00"
    """
    return datetime.now().strftime(format)


def log(*message):
    """Logs a message to standard output with a timestamp.
    @param message <any>:
        Values printed to log
    """
    print("[{0}] {1}".format(
        timestamp(),
        " ".join([str(m) for m in message]))
    )


def check_permissions(parser, path, *args, **kwargs):
    """Checks permissions using os.access() to see the
    user is authorized to access a file/directory. Checks
    for existence, read, write and execute via args:
        • os.F_OK (tests existence)
        • os.R_OK (tests read)
        • os.W_OK (tests write)
        • os.X_OK (tests exec)
    @param parser <argparse.ArgumentParser() object>:
        Argparse parser object
    @param path <str>:
        Name of path to check
    @param args <any>:
        Positional args to pass to os.access()
    @param kwargs <any>:
        Named kwargs to pass to os.access()
    @return path <str>:
        Returns absolute path if it exists and the
        checked permssions are setup are correct.
    """
    if not os.path.exists(path):
        parser.error(
            "Path '{}' does not exists! Failed to provide vaild input.".format(path)
        )
    if not os.access(path, *args, **kwargs):
        parser.error(
            "Path '{}' exists, but cannot read path due to permissions!".format(path)
        )
    return os.path.abspath(path)


def parse_cli_arguments():
    """Parses command line arguments and returns
    an argparse.parse_args object.
    @return <argparse.parse_args()>:
        Parsed command line arguments
    """
    parser = argparse.ArgumentParser(
        add_help=False,
        description=_HELP,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage = argparse.SUPPRESS,
    )
    # Exon annotation file
    parser.add_argument(
        '-e', '--exon-ann',
        type = lambda file: \
            check_permissions(parser, file, os.R_OK),
        required=True,
        help=argparse.SUPPRESS
    )
    # Annotated output results
    parser.add_argument(
        '-o', '--output',
        type = str,
        required=True,
        help=argparse.SUPPRESS
    )
    # Get version information
    parser.add_argument(
        '-v', '--version',
        action='version',
        help = argparse.SUPPRESS,
        version='%(prog)s {0}'.format(_VERISON)
    )
    # Add custom help message
    parser.add_argument(
        '-h', '--help',
        action='help',
        help=argparse.SUPPRESS
    )
    return parser.parse_args()


def stripped(s):
    """Cleans string to remove quotes
    @param s <str>:
        String to remove quotes or clean
    @return s <str>:
        Cleaned string with quotes removed
    """
    return s.strip('"').strip("'")


def index_header(file_header):
    """Returns the index of each column_name
    as a dictionary.
    @param file_header <str>:
        First line of a file, containing column names
    @return idx <dict[str]=int>:
        Column name to index dictionary
    """
    idx = {}
    tokens = [
        stripped(c.strip()) \
            for c in file_header.strip().split('\t')
    ]
    # Create column name to index mapping
    for i,c in enumerate(tokens):
        idx[c]=i
    return idx


def index_file(
        file, key = "transcript_id",
        single_value_columns=["transcript_name", "gene_id", "gene_name"],
        multi_value_columns=["exon_id", "exon_number", "exon_seqname","exon_start_end", "exon_strand"],
        multi_value_key_name="exon_metadata"
    ):
    """Parses and indexes a file into a dictionary for quick
    lookups later. This file is indexed by keys representing
    transcript_ids and a nested dictionary of containing the
    following information:
        • gene_id
        • gene_name
        • transcript_name
        • exon_metadata (list of lists):
            • [[id, number, seqname, start, end, strand], ...]
    @param file <str>:
        File to parse and index. Must contain a header with
        the columns listed in keys and values. The index of
        these columns will be automatically resolved.
    @param key <str>:
        Key to use for the first level of the index. Defaults
        to "transcript_id". This is the first key in the
        nested dictionary.
    @param single_value_columns <list[str]>:
        List of columns that contain single values per key.
        These are the second keys in the nested dictionary.
    @param multi_value_columns <list[str]>:
        List of columns that contain multiple values per key.
        These values are stored as a list of lists in the
        nested dictionary under the key "exon_metadata".
        This represents the exon information for each
        transcript. Each element in the returned list is
        a list containing the following information:
            • [0] exon_id
            • [1] exon_number
            • [2] exon_seqname
            • [3] exon_start
            • [4] exon_end
            • [5] strand
    @param multi_value_key_name <str>:
        Name of the key in the nested dictionary that contains
        the multi-value columns. Defaults to "exon_metadata".
    @return file_idx <dict[str]=str>:
        Nested dictionary where,
            • 1st_key = transcript_id
            • 2nd_key = one of the following:
              gene_id|gene_name|transcript_name|exon_metadata
    @note: file_idx[transcript_id][exon_metadata] returns a
    list of lists, where each element in the list has been
    sorted on seqname, start, end, strand.
    """
    log("Started indexing input file: {0}".format(file))
    file_idx = {}
    # Handler for opening files, i.e.
    # uncompressed or gzip files
    open_func = gzip.open if file.endswith('.gz') else open
    line_number = 0  # Used for error reporting
    with open_func(file, 'rt') as fh:
        header = next(fh)
        col_idx = index_header(header)
        for line in fh:
            # Increment line number
            line_number += 1
            # Split the line into columns
            tokens = line.strip().split('\t')
            # Concatenate mutiple keys into
            # a single key separated by the
            # key_delim character
            _k = tokens[col_idx[key]]  # _k represents transcript_id
            _v = {v: get_with_default(tokens,col_idx,v) for v in single_value_columns}
            if _k not in file_idx:
                # Create a new entry in the index
                # with the single value columns
                # this prevents it from being
                # overwritten in every iteration.
                # The values in _v should be the
                # same on every line for each
                # transcript_id.
                file_idx[_k] = _v
            # Parse multi-value columns
            _multi_values = [get_with_default(tokens,col_idx,v) for v in multi_value_columns]
            # Add multi-value columns to the
            # file_idx under the multi_value_key_name
            if multi_value_key_name not in file_idx[_k]:
                file_idx[_k][multi_value_key_name] = []
            # Append the multi-value columns
            file_idx[_k][multi_value_key_name].append(_multi_values)
    log("Finished indexing input file: {0} ({1} lines)".format(file, line_number))
    return file_idx


def get_with_default(line_list, column_name_idx_dict, column_name, default_value="NA"):
    """Get a value from a list using the column name index
    dictionary. If the column name does not exist in the
    dictionary, return the default value (i.e "NA").
    @param line_list <list[str]>:
        List of values from a line in a file. This is the
        list that get are retrieving information from.
        This function is used to return a value (with a
        default value if missing) from within a list or
        dictionary comprehension.
    @param column_name_idx_dict <dict[str]=int>:
        Dictionary mapping column names to their index
    @param column_name <str>:
        Column name to look up in the dictionary
    @param default_value <str>:
        Default value to return if the column name does not
        exist in the dictionary. Defaults to "NA".
    @return value <str>:
        Value from the list at the index of the column name,
        or the default value if the column name does not exist.
    """
    # Default value to return if column name DNE
    parsed_value = default_value
    # Try to get the index of the column name
    # This can result in a KeyError/IndexError
    # if the column name does not exist in the
    # dict. This can be caused upstream of this
    # program if this 9th column in the GTF file
    # is missing attributes that we expect to be
    # present, i.e gene_id, gene_name, exon_number,
    # etc. These should be present in 99% of GTF
    # files, but it is possible that some files do
    # not contain these attributes. Of all the
    # attributes that are expected, the exon_number
    # may not always be present; however, that is
    # okay. It isn't be used in a meaningful way.
    if column_name in column_name_idx_dict:
        # Get the index of the column name
        # from the dictionary.
        # This will raise a KeyError if the
        # column name does not exist in the dict.
        list_idx = column_name_idx_dict[column_name]
        if list_idx < len(line_list):
            # If the index is within the bounds of the list,
            # return the value at that index.
            parsed_value = line_list[list_idx]
            # Remove quotes from the value
            parsed_value = stripped(parsed_value)
    return parsed_value


if __name__ == '__main__':
    # Parse command line arguments
    args = parse_cli_arguments()

    # Sanity check for usage
    if len(sys.argv) == 1:
        # Nothing was provided
        fatal('Invalid usage: {0} [-h] ...'.format(os.path.basename(sys.argv[0])))

    log("Running splicing annotation script with the following options: ", args)
    # Create output directory if
    # it does not exist
    output_dir = os.path.abspath(os.path.dirname(args.output))
    if not os.path.exists(output_dir):
        try: os.makedirs(output_dir)
        except OSError as e:
            fatal(
                "Fatal error: Failed to create output directory: {0}\n{1}".format(
                    output_dir, e
                )
            )

    # Parse and collapse exon annotation
    # information for each transcript,
    # where 1:M exon information is
    # sorted by chr/start/end/strand,
    # meaning it is in the same order
    # as the spliced transcript.
    FIRST_KEY = "transcript_id"
    EXON_1toM_KEY = "exon_metadata"
    PARSE_1to1_COLUMNS = [
        "transcript_name",
        "gene_id",
        "gene_name"
    ]
    PARSE_1toM_COLUMNS = [
        "exon_id",
        "exon_number",
        "exon_seqname",
        "exon_start",
        "exon_end",
        "exon_strand"
    ]
    splicing_dict = index_file(
        file=args.exon_ann,
        key = FIRST_KEY,
        single_value_columns=PARSE_1to1_COLUMNS,
        multi_value_columns=PARSE_1toM_COLUMNS,
        multi_value_key_name=EXON_1toM_KEY
    )
    log("Starting sorting exon information by seqname, start, end, strand")
    # Sort the multi-value columns by
    # seqname, start, end, strand
    for k, v in splicing_dict.items():
        if EXON_1toM_KEY in v:
            # Sort the list of lists by:
            # seqname, start, end, strand
            v[EXON_1toM_KEY].sort(
                key=lambda x: (
                    x[PARSE_1toM_COLUMNS.index("exon_seqname")],
                    int(x[PARSE_1toM_COLUMNS.index("exon_start")]),
                    int(x[PARSE_1toM_COLUMNS.index("exon_end")]),
                    x[PARSE_1toM_COLUMNS.index("exon_strand")]
                )
            )
            # Get the strand information
            # for the first exon in the list
            # to determine if the order
            # needs to be reversed.
            if v[EXON_1toM_KEY][0][PARSE_1toM_COLUMNS.index("exon_strand")] == "-":
                # If the strand is negative,
                # reverse the order of the exon
                # information to reflect the
                # correct splicing order.
                v[EXON_1toM_KEY].reverse()
    log("Finished sorting exon information by seqname, start, end, strand")
    # Write the splicing annotation to the output file
    log("Writing splicing annotation to output file: ", args.output)
    MISSING_VALUES = ["NA", "Unknown", ""]
    with open(args.output, 'w') as out_fh:
        # Write the header line
        out_fh.write(
            "\t".join([
                "transcript_id","transcript_name",
                "gene_id","gene_name",
                "exon_id","exon_number",
                "exon_seqname","exon_start_end",
                "exon_strand"
            ]) + "\n"
        )
        # Write the splicing annotation
        for transcript_id, data in splicing_dict.items():
            exon_metadata = data[EXON_1toM_KEY]
            exon_ids = "|".join([x[PARSE_1toM_COLUMNS.index("exon_id")] for x in exon_metadata])
            # Replace missing values with their
            # index after coordinate sorting
            exon_numbers = [x[PARSE_1toM_COLUMNS.index("exon_number")] for x in exon_metadata]
            exon_numbers = [i if e in MISSING_VALUES else e for i,e in enumerate(exon_numbers)]
            exon_numbers = "|".join(exon_numbers)
            # NOTE: All strand information should
            # be the same for a given transcript.
            exon_seqnames = "|".join(list(set([x[PARSE_1toM_COLUMNS.index("exon_seqname")] for x in exon_metadata])))
            exon_start_ends = "|".join(
                ["{0}:{1}".format(
                    x[PARSE_1toM_COLUMNS.index("exon_start")], x[PARSE_1toM_COLUMNS.index("exon_end")]
                ) for x in exon_metadata]
            )
            # NOTE: All strand information should
            # be the same for a given transcript.
            exon_strands = "|".join(list(set([x[PARSE_1toM_COLUMNS.index("exon_strand")] for x in exon_metadata])))
            out_fh.write(
                "\t".join([
                    transcript_id,
                    data["transcript_name"],
                    data["gene_id"],
                    data["gene_name"],
                    exon_ids,
                    exon_numbers,
                    exon_seqnames,
                    exon_start_ends,
                    exon_strands
                ]) + "\n"
            )
    log("Finished writing splicing annotation to output file: ", args.output)
    log("Splicing annotation script completed successfully!")